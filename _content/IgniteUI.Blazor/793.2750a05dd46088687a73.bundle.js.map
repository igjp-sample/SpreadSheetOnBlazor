{"version":3,"file":"793.2750a05dd46088687a73.bundle.js","mappings":"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","sources":["webpack://InfragisticsBlazor/../node_modules/@lit-labs/virtualizer/layouts/shared/SizeCache.js","webpack://InfragisticsBlazor/../node_modules/@lit-labs/virtualizer/layouts/shared/BaseLayout.js","webpack://InfragisticsBlazor/../node_modules/@lit-labs/virtualizer/layouts/flow.js"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nexport class SizeCache {\n    constructor(config) {\n        this._map = new Map();\n        this._roundAverageSize = false;\n        this.totalSize = 0;\n        if ((config === null || config === void 0 ? void 0 : config.roundAverageSize) === true) {\n            this._roundAverageSize = true;\n        }\n    }\n    set(index, value) {\n        const prev = this._map.get(index) || 0;\n        this._map.set(index, value);\n        this.totalSize += value - prev;\n    }\n    get averageSize() {\n        if (this._map.size > 0) {\n            const average = this.totalSize / this._map.size;\n            return this._roundAverageSize ? Math.round(average) : average;\n        }\n        return 0;\n    }\n    getSize(index) {\n        return this._map.get(index);\n    }\n    clear() {\n        this._map.clear();\n        this.totalSize = 0;\n    }\n}\n//# sourceMappingURL=SizeCache.js.map","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nexport function dim1(direction) {\n    return direction === 'horizontal' ? 'width' : 'height';\n}\nexport function dim2(direction) {\n    return direction === 'horizontal' ? 'height' : 'width';\n}\nexport function pos1(direction) {\n    return direction === 'horizontal' ? 'left' : 'top';\n}\nexport function pos2(direction) {\n    return direction === 'horizontal' ? 'top' : 'left';\n}\nexport class BaseLayout {\n    constructor(hostSink, config) {\n        /**\n         * The last set viewport scroll position.\n         */\n        this._latestCoords = { left: 0, top: 0 };\n        /**\n         * Scrolling direction.\n         */\n        this._direction = null;\n        /**\n         * Dimensions of the viewport.\n         */\n        this._viewportSize = { width: 0, height: 0 };\n        this.totalScrollSize = { width: 0, height: 0 };\n        this.offsetWithinScroller = { left: 0, top: 0 };\n        /**\n         * Flag for debouncing asynchronous reflow requests.\n         */\n        this._pendingReflow = false;\n        this._pendingLayoutUpdate = false;\n        this._pin = null;\n        /**\n         * The index of the first item intersecting the viewport.\n         */\n        this._firstVisible = 0;\n        /**\n         * The index of the last item intersecting the viewport.\n         */\n        this._lastVisible = 0;\n        /**\n         * Pixel offset in the scroll direction of the first child.\n         */\n        this._physicalMin = 0;\n        /**\n         * Pixel offset in the scroll direction of the last child.\n         */\n        this._physicalMax = 0;\n        /**\n         * Index of the first child.\n         */\n        this._first = -1;\n        /**\n         * Index of the last child.\n         */\n        this._last = -1;\n        /**\n         * Length in the scrolling direction.\n         */\n        this._sizeDim = 'height';\n        /**\n         * Length in the non-scrolling direction.\n         */\n        this._secondarySizeDim = 'width';\n        /**\n         * Position in the scrolling direction.\n         */\n        this._positionDim = 'top';\n        /**\n         * Position in the non-scrolling direction.\n         */\n        this._secondaryPositionDim = 'left';\n        /**\n         * Current scroll offset in pixels.\n         */\n        this._scrollPosition = 0;\n        /**\n         * Difference between current scroll offset and scroll offset calculated due\n         * to a reflow.\n         */\n        this._scrollError = 0;\n        /**\n         * Total number of items that could possibly be displayed. Used to help\n         * calculate the scroll size.\n         */\n        this._items = [];\n        /**\n         * The total (estimated) length of all items in the scrolling direction.\n         */\n        this._scrollSize = 1;\n        /**\n         * Number of pixels beyond the viewport to still include\n         * in the active range of items.\n         */\n        // TODO (graynorton): Probably want to make this something we calculate based\n        // on viewport size, item size, other factors, possibly still with a dial of some kind\n        this._overhang = 1000;\n        this._hostSink = hostSink;\n        // Delay setting config so that subclasses do setup work first\n        Promise.resolve().then(() => (this.config = config || this._getDefaultConfig()));\n    }\n    _getDefaultConfig() {\n        return {\n            direction: 'vertical',\n        };\n    }\n    set config(config) {\n        Object.assign(this, Object.assign({}, this._getDefaultConfig(), config));\n    }\n    get config() {\n        return {\n            direction: this.direction,\n        };\n    }\n    /**\n     * Maximum index of children + 1, to help estimate total height of the scroll\n     * space.\n     */\n    get items() {\n        return this._items;\n    }\n    set items(items) {\n        this._setItems(items);\n    }\n    _setItems(items) {\n        if (items !== this._items) {\n            this._items = items;\n            this._scheduleReflow();\n        }\n    }\n    /**\n     * Primary scrolling direction.\n     */\n    get direction() {\n        return this._direction;\n    }\n    set direction(dir) {\n        // Force it to be either horizontal or vertical.\n        dir = dir === 'horizontal' ? dir : 'vertical';\n        if (dir !== this._direction) {\n            this._direction = dir;\n            this._sizeDim = dir === 'horizontal' ? 'width' : 'height';\n            this._secondarySizeDim = dir === 'horizontal' ? 'height' : 'width';\n            this._positionDim = dir === 'horizontal' ? 'left' : 'top';\n            this._secondaryPositionDim = dir === 'horizontal' ? 'top' : 'left';\n            this._triggerReflow();\n        }\n    }\n    /**\n     * Height and width of the viewport.\n     */\n    get viewportSize() {\n        return this._viewportSize;\n    }\n    set viewportSize(dims) {\n        const { _viewDim1, _viewDim2 } = this;\n        Object.assign(this._viewportSize, dims);\n        if (_viewDim2 !== this._viewDim2) {\n            // this._viewDim2Changed();\n            this._scheduleLayoutUpdate();\n        }\n        else if (_viewDim1 !== this._viewDim1) {\n            this._checkThresholds();\n        }\n    }\n    /**\n     * Scroll offset of the viewport.\n     */\n    get viewportScroll() {\n        return this._latestCoords;\n    }\n    set viewportScroll(coords) {\n        Object.assign(this._latestCoords, coords);\n        const oldPos = this._scrollPosition;\n        this._scrollPosition = this._latestCoords[this._positionDim];\n        const change = Math.abs(oldPos - this._scrollPosition);\n        if (change >= 1) {\n            this._checkThresholds();\n        }\n    }\n    /**\n     * Perform a reflow if one has been scheduled.\n     */\n    reflowIfNeeded(force = false) {\n        if (force || this._pendingReflow) {\n            this._pendingReflow = false;\n            this._reflow();\n        }\n    }\n    set pin(options) {\n        this._pin = options;\n        this._triggerReflow();\n    }\n    get pin() {\n        if (this._pin !== null) {\n            const { index, block } = this._pin;\n            return {\n                index: Math.max(0, Math.min(index, this.items.length - 1)),\n                block,\n            };\n        }\n        return null;\n    }\n    _clampScrollPosition(val) {\n        return Math.max(-this.offsetWithinScroller[this._positionDim], Math.min(val, this.totalScrollSize[dim1(this.direction)] - this._viewDim1));\n    }\n    unpin() {\n        if (this._pin !== null) {\n            this._sendUnpinnedMessage();\n            this._pin = null;\n        }\n    }\n    _updateLayout() {\n        // Override\n    }\n    // protected _viewDim2Changed(): void {\n    //   this._scheduleLayoutUpdate();\n    // }\n    /**\n     * The height or width of the viewport, whichever corresponds to the scrolling direction.\n     */\n    get _viewDim1() {\n        return this._viewportSize[this._sizeDim];\n    }\n    /**\n     * The height or width of the viewport, whichever does NOT correspond to the scrolling direction.\n     */\n    get _viewDim2() {\n        return this._viewportSize[this._secondarySizeDim];\n    }\n    _scheduleReflow() {\n        this._pendingReflow = true;\n    }\n    _scheduleLayoutUpdate() {\n        this._pendingLayoutUpdate = true;\n        this._scheduleReflow();\n    }\n    // For triggering a reflow based on incoming changes to\n    // the layout config.\n    _triggerReflow() {\n        this._scheduleLayoutUpdate();\n        // TODO graynorton@: reflowIfNeeded() isn't really supposed\n        // to be called internally. Address in larger cleanup\n        // of virtualizer / layout interaction pattern.\n        // this.reflowIfNeeded(true);\n        Promise.resolve().then(() => this.reflowIfNeeded());\n    }\n    _reflow() {\n        if (this._pendingLayoutUpdate) {\n            this._updateLayout();\n            this._pendingLayoutUpdate = false;\n        }\n        this._updateScrollSize();\n        this._setPositionFromPin();\n        this._getActiveItems();\n        this._updateVisibleIndices();\n        this._sendStateChangedMessage();\n    }\n    /**\n     * If we are supposed to be pinned to a particular\n     * item or set of coordinates, we set `_scrollPosition`\n     * accordingly and adjust `_scrollError` as needed\n     * so that the virtualizer can keep the scroll\n     * position in the DOM in sync\n     */\n    _setPositionFromPin() {\n        if (this.pin !== null) {\n            const lastScrollPosition = this._scrollPosition;\n            const { index, block } = this.pin;\n            this._scrollPosition =\n                this._calculateScrollIntoViewPosition({\n                    index,\n                    block: block || 'start',\n                }) - this.offsetWithinScroller[this._positionDim];\n            this._scrollError = lastScrollPosition - this._scrollPosition;\n        }\n    }\n    /**\n     * Calculate the coordinates to scroll to, given\n     * a request to scroll to the element at a specific\n     * index.\n     *\n     * Supports the same positioning options (`start`,\n     * `center`, `end`, `nearest`) as the standard\n     * `Element.scrollIntoView()` method, but currently\n     * only considers the provided value in the `block`\n     * dimension, since we don't yet have any layouts\n     * that support virtualization in two dimensions.\n     */\n    _calculateScrollIntoViewPosition(options) {\n        const { block } = options;\n        const index = Math.min(this.items.length, Math.max(0, options.index));\n        const itemStartPosition = this._getItemPosition(index)[this._positionDim];\n        let scrollPosition = itemStartPosition;\n        if (block !== 'start') {\n            const itemSize = this._getItemSize(index)[this._sizeDim];\n            if (block === 'center') {\n                scrollPosition =\n                    itemStartPosition - 0.5 * this._viewDim1 + 0.5 * itemSize;\n            }\n            else {\n                const itemEndPosition = itemStartPosition - this._viewDim1 + itemSize;\n                if (block === 'end') {\n                    scrollPosition = itemEndPosition;\n                }\n                else {\n                    // block === 'nearest'\n                    const currentScrollPosition = this._scrollPosition;\n                    scrollPosition =\n                        Math.abs(currentScrollPosition - itemStartPosition) <\n                            Math.abs(currentScrollPosition - itemEndPosition)\n                            ? itemStartPosition\n                            : itemEndPosition;\n                }\n            }\n        }\n        scrollPosition += this.offsetWithinScroller[this._positionDim];\n        return this._clampScrollPosition(scrollPosition);\n    }\n    getScrollIntoViewCoordinates(options) {\n        return {\n            [this._positionDim]: this._calculateScrollIntoViewPosition(options),\n        };\n    }\n    _sendUnpinnedMessage() {\n        this._hostSink({\n            type: 'unpinned',\n        });\n    }\n    _sendVisibilityChangedMessage() {\n        this._hostSink({\n            type: 'visibilityChanged',\n            firstVisible: this._firstVisible,\n            lastVisible: this._lastVisible,\n        });\n    }\n    _sendStateChangedMessage() {\n        const childPositions = new Map();\n        if (this._first !== -1 && this._last !== -1) {\n            for (let idx = this._first; idx <= this._last; idx++) {\n                childPositions.set(idx, this._getItemPosition(idx));\n            }\n        }\n        const message = {\n            type: 'stateChanged',\n            scrollSize: {\n                [this._sizeDim]: this._scrollSize,\n                [this._secondarySizeDim]: null,\n            },\n            range: {\n                first: this._first,\n                last: this._last,\n                firstVisible: this._firstVisible,\n                lastVisible: this._lastVisible,\n            },\n            childPositions,\n        };\n        if (this._scrollError) {\n            message.scrollError = {\n                [this._positionDim]: this._scrollError,\n                [this._secondaryPositionDim]: 0,\n            };\n            this._scrollError = 0;\n        }\n        this._hostSink(message);\n    }\n    /**\n     * Number of items to display.\n     */\n    get _num() {\n        if (this._first === -1 || this._last === -1) {\n            return 0;\n        }\n        return this._last - this._first + 1;\n    }\n    _checkThresholds() {\n        if ((this._viewDim1 === 0 && this._num > 0) || this._pin !== null) {\n            this._scheduleReflow();\n        }\n        else {\n            const min = Math.max(0, this._scrollPosition - this._overhang);\n            const max = Math.min(this._scrollSize, this._scrollPosition + this._viewDim1 + this._overhang);\n            if (this._physicalMin > min || this._physicalMax < max) {\n                this._scheduleReflow();\n            }\n            else {\n                this._updateVisibleIndices({ emit: true });\n            }\n        }\n    }\n    /**\n     * Find the indices of the first and last items to intersect the viewport.\n     * Emit a visibleindiceschange event when either index changes.\n     */\n    _updateVisibleIndices(options) {\n        if (this._first === -1 || this._last === -1)\n            return;\n        let firstVisible = this._first;\n        while (firstVisible < this._last &&\n            Math.round(this._getItemPosition(firstVisible)[this._positionDim] +\n                this._getItemSize(firstVisible)[this._sizeDim]) <= Math.round(this._scrollPosition)) {\n            firstVisible++;\n        }\n        let lastVisible = this._last;\n        while (lastVisible > this._first &&\n            Math.round(this._getItemPosition(lastVisible)[this._positionDim]) >=\n                Math.round(this._scrollPosition + this._viewDim1)) {\n            lastVisible--;\n        }\n        if (firstVisible !== this._firstVisible ||\n            lastVisible !== this._lastVisible) {\n            this._firstVisible = firstVisible;\n            this._lastVisible = lastVisible;\n            if (options && options.emit) {\n                this._sendVisibilityChangedMessage();\n            }\n        }\n    }\n}\n//# sourceMappingURL=BaseLayout.js.map","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { SizeCache } from './shared/SizeCache.js';\nimport { BaseLayout, dim1 } from './shared/BaseLayout.js';\nexport const flow = (config) => Object.assign({\n    type: FlowLayout,\n}, config);\nfunction leadingMargin(direction) {\n    return direction === 'horizontal' ? 'marginLeft' : 'marginTop';\n}\nfunction trailingMargin(direction) {\n    return direction === 'horizontal' ? 'marginRight' : 'marginBottom';\n}\nfunction offset(direction) {\n    return direction === 'horizontal' ? 'xOffset' : 'yOffset';\n}\nfunction collapseMargins(a, b) {\n    const m = [a, b].sort();\n    return m[1] <= 0 ? Math.min(...m) : m[0] >= 0 ? Math.max(...m) : m[0] + m[1];\n}\nclass MetricsCache {\n    constructor() {\n        this._childSizeCache = new SizeCache();\n        this._marginSizeCache = new SizeCache();\n        this._metricsCache = new Map();\n    }\n    update(metrics, direction) {\n        var _a, _b;\n        const marginsToUpdate = new Set();\n        Object.keys(metrics).forEach((key) => {\n            const k = Number(key);\n            this._metricsCache.set(k, metrics[k]);\n            this._childSizeCache.set(k, metrics[k][dim1(direction)]);\n            marginsToUpdate.add(k);\n            marginsToUpdate.add(k + 1);\n        });\n        for (const k of marginsToUpdate) {\n            const a = ((_a = this._metricsCache.get(k)) === null || _a === void 0 ? void 0 : _a[leadingMargin(direction)]) || 0;\n            const b = ((_b = this._metricsCache.get(k - 1)) === null || _b === void 0 ? void 0 : _b[trailingMargin(direction)]) || 0;\n            this._marginSizeCache.set(k, collapseMargins(a, b));\n        }\n    }\n    get averageChildSize() {\n        return this._childSizeCache.averageSize;\n    }\n    get totalChildSize() {\n        return this._childSizeCache.totalSize;\n    }\n    get averageMarginSize() {\n        return this._marginSizeCache.averageSize;\n    }\n    get totalMarginSize() {\n        return this._marginSizeCache.totalSize;\n    }\n    getLeadingMarginValue(index, direction) {\n        var _a;\n        return ((_a = this._metricsCache.get(index)) === null || _a === void 0 ? void 0 : _a[leadingMargin(direction)]) || 0;\n    }\n    getChildSize(index) {\n        return this._childSizeCache.getSize(index);\n    }\n    getMarginSize(index) {\n        return this._marginSizeCache.getSize(index);\n    }\n    clear() {\n        this._childSizeCache.clear();\n        this._marginSizeCache.clear();\n        this._metricsCache.clear();\n    }\n}\nexport class FlowLayout extends BaseLayout {\n    constructor() {\n        super(...arguments);\n        /**\n         * Initial estimate of item size\n         */\n        this._itemSize = { width: 100, height: 100 };\n        /**\n         * Indices of children mapped to their (position and length) in the scrolling\n         * direction. Used to keep track of children that are in range.\n         */\n        this._physicalItems = new Map();\n        /**\n         * Used in tandem with _physicalItems to track children in range across\n         * reflows.\n         */\n        this._newPhysicalItems = new Map();\n        /**\n         * Width and height of children by their index.\n         */\n        this._metricsCache = new MetricsCache();\n        /**\n         * anchorIdx is the anchor around which we reflow. It is designed to allow\n         * jumping to any point of the scroll size. We choose it once and stick with\n         * it until stable. _first and _last are deduced around it.\n         */\n        this._anchorIdx = null;\n        /**\n         * Position in the scrolling direction of the anchor child.\n         */\n        this._anchorPos = null;\n        /**\n         * Whether all children in range were in range during the previous reflow.\n         */\n        this._stable = true;\n        this._measureChildren = true;\n        this._estimate = true;\n    }\n    // protected _defaultConfig: BaseLayoutConfig = Object.assign({}, super._defaultConfig, {\n    // })\n    // constructor(config: Layout1dConfig) {\n    //   super(config);\n    // }\n    get measureChildren() {\n        return this._measureChildren;\n    }\n    /**\n     * Determine the average size of all children represented in the sizes\n     * argument.\n     */\n    updateItemSizes(sizes) {\n        this._metricsCache.update(sizes, this.direction);\n        // if (this._nMeasured) {\n        // this._updateItemSize();\n        this._scheduleReflow();\n        // }\n    }\n    /**\n     * Set the average item size based on the total length and number of children\n     * in range.\n     */\n    // _updateItemSize() {\n    //   // Keep integer values.\n    //   this._itemSize[this._sizeDim] = this._metricsCache.averageChildSize;\n    // }\n    _getPhysicalItem(idx) {\n        var _a;\n        return (_a = this._newPhysicalItems.get(idx)) !== null && _a !== void 0 ? _a : this._physicalItems.get(idx);\n    }\n    _getSize(idx) {\n        const item = this._getPhysicalItem(idx);\n        return item && this._metricsCache.getChildSize(idx);\n    }\n    _getAverageSize() {\n        return this._metricsCache.averageChildSize || this._itemSize[this._sizeDim];\n    }\n    _estimatePosition(idx) {\n        const c = this._metricsCache;\n        if (this._first === -1 || this._last === -1) {\n            return (c.averageMarginSize +\n                idx * (c.averageMarginSize + this._getAverageSize()));\n        }\n        else {\n            if (idx < this._first) {\n                const delta = this._first - idx;\n                const refItem = this._getPhysicalItem(this._first);\n                return (refItem.pos -\n                    (c.getMarginSize(this._first - 1) || c.averageMarginSize) -\n                    (delta * c.averageChildSize + (delta - 1) * c.averageMarginSize));\n            }\n            else {\n                const delta = idx - this._last;\n                const refItem = this._getPhysicalItem(this._last);\n                return (refItem.pos +\n                    (c.getChildSize(this._last) || c.averageChildSize) +\n                    (c.getMarginSize(this._last) || c.averageMarginSize) +\n                    delta * (c.averageChildSize + c.averageMarginSize));\n            }\n        }\n    }\n    /**\n     * Returns the position in the scrolling direction of the item at idx.\n     * Estimates it if the item at idx is not in the DOM.\n     */\n    _getPosition(idx) {\n        var _a;\n        const item = this._getPhysicalItem(idx);\n        const { averageMarginSize } = this._metricsCache;\n        return idx === 0\n            ? (_a = this._metricsCache.getMarginSize(0)) !== null && _a !== void 0 ? _a : averageMarginSize\n            : item\n                ? item.pos\n                : this._estimatePosition(idx);\n    }\n    _calculateAnchor(lower, upper) {\n        if (lower <= 0) {\n            return 0;\n        }\n        if (upper > this._scrollSize - this._viewDim1) {\n            return this.items.length - 1;\n        }\n        return Math.max(0, Math.min(this.items.length - 1, Math.floor((lower + upper) / 2 / this._delta)));\n    }\n    _getAnchor(lower, upper) {\n        if (this._physicalItems.size === 0) {\n            return this._calculateAnchor(lower, upper);\n        }\n        if (this._first < 0) {\n            return this._calculateAnchor(lower, upper);\n        }\n        if (this._last < 0) {\n            return this._calculateAnchor(lower, upper);\n        }\n        const firstItem = this._getPhysicalItem(this._first), lastItem = this._getPhysicalItem(this._last), firstMin = firstItem.pos, lastMin = lastItem.pos, lastMax = lastMin + this._metricsCache.getChildSize(this._last);\n        if (lastMax < lower) {\n            // Window is entirely past physical items, calculate new anchor\n            return this._calculateAnchor(lower, upper);\n        }\n        if (firstMin > upper) {\n            // Window is entirely before physical items, calculate new anchor\n            return this._calculateAnchor(lower, upper);\n        }\n        // Window contains a physical item\n        // Find one, starting with the one that was previously first visible\n        let candidateIdx = this._firstVisible - 1;\n        let cMax = -Infinity;\n        while (cMax < lower) {\n            const candidate = this._getPhysicalItem(++candidateIdx);\n            cMax = candidate.pos + this._metricsCache.getChildSize(candidateIdx);\n        }\n        return candidateIdx;\n    }\n    /**\n     * Updates _first and _last based on items that should be in the current\n     * viewed range.\n     */\n    _getActiveItems() {\n        if (this._viewDim1 === 0 || this.items.length === 0) {\n            this._clearItems();\n        }\n        else {\n            this._getItems();\n        }\n    }\n    /**\n     * Sets the range to empty.\n     */\n    _clearItems() {\n        this._first = -1;\n        this._last = -1;\n        this._physicalMin = 0;\n        this._physicalMax = 0;\n        const items = this._newPhysicalItems;\n        this._newPhysicalItems = this._physicalItems;\n        this._newPhysicalItems.clear();\n        this._physicalItems = items;\n        this._stable = true;\n    }\n    /*\n     * Updates _first and _last based on items that should be in the given range.\n     */\n    _getItems() {\n        var _a, _b;\n        const items = this._newPhysicalItems;\n        this._stable = true;\n        let lower, upper;\n        // The anchorIdx is the anchor around which we reflow. It is designed to\n        // allow jumping to any point of the scroll size. We choose it once and\n        // stick with it until stable. first and last are deduced around it.\n        // If we have a pinned item, we anchor on it\n        if (this.pin !== null) {\n            const { index } = this.pin;\n            this._anchorIdx = index;\n            this._anchorPos = this._getPosition(index);\n        }\n        // Determine the lower and upper bounds of the region to be\n        // rendered, relative to the viewport\n        lower = this._scrollPosition - this._overhang; //leadingOverhang;\n        upper = this._scrollPosition + this._viewDim1 + this._overhang; // trailingOverhang;\n        if (upper < 0 || lower > this._scrollSize) {\n            this._clearItems();\n            return;\n        }\n        // If we are scrolling to a specific index or if we are doing another\n        // pass to stabilize a previously started reflow, we will already\n        // have an anchor. If not, establish an anchor now.\n        if (this._anchorIdx === null || this._anchorPos === null) {\n            this._anchorIdx = this._getAnchor(lower, upper);\n            this._anchorPos = this._getPosition(this._anchorIdx);\n        }\n        let anchorSize = this._getSize(this._anchorIdx);\n        if (anchorSize === undefined) {\n            this._stable = false;\n            anchorSize = this._getAverageSize();\n        }\n        const anchorLeadingMargin = (_a = this._metricsCache.getMarginSize(this._anchorIdx)) !== null && _a !== void 0 ? _a : this._metricsCache.averageMarginSize;\n        const anchorTrailingMargin = (_b = this._metricsCache.getMarginSize(this._anchorIdx + 1)) !== null && _b !== void 0 ? _b : this._metricsCache.averageMarginSize;\n        if (this._anchorIdx === 0) {\n            this._anchorPos = anchorLeadingMargin;\n        }\n        if (this._anchorIdx === this.items.length - 1) {\n            this._anchorPos = this._scrollSize - anchorTrailingMargin - anchorSize;\n        }\n        // Anchor might be outside bounds, so prefer correcting the error and keep\n        // that anchorIdx.\n        let anchorErr = 0;\n        if (this._anchorPos + anchorSize + anchorTrailingMargin < lower) {\n            anchorErr = lower - (this._anchorPos + anchorSize + anchorTrailingMargin);\n        }\n        if (this._anchorPos - anchorLeadingMargin > upper) {\n            anchorErr = upper - (this._anchorPos - anchorLeadingMargin);\n        }\n        if (anchorErr) {\n            this._scrollPosition -= anchorErr;\n            lower -= anchorErr;\n            upper -= anchorErr;\n            this._scrollError += anchorErr;\n        }\n        items.set(this._anchorIdx, { pos: this._anchorPos, size: anchorSize });\n        this._first = this._last = this._anchorIdx;\n        this._physicalMin = this._anchorPos - anchorLeadingMargin;\n        this._physicalMax = this._anchorPos + anchorSize + anchorTrailingMargin;\n        while (this._physicalMin > lower && this._first > 0) {\n            let size = this._getSize(--this._first);\n            if (size === undefined) {\n                this._stable = false;\n                size = this._getAverageSize();\n            }\n            let margin = this._metricsCache.getMarginSize(this._first);\n            if (margin === undefined) {\n                this._stable = false;\n                margin = this._metricsCache.averageMarginSize;\n            }\n            this._physicalMin -= size;\n            const pos = this._physicalMin;\n            items.set(this._first, { pos, size });\n            this._physicalMin -= margin;\n            if (this._stable === false && this._estimate === false) {\n                break;\n            }\n        }\n        while (this._physicalMax < upper && this._last < this.items.length - 1) {\n            let size = this._getSize(++this._last);\n            if (size === undefined) {\n                this._stable = false;\n                size = this._getAverageSize();\n            }\n            let margin = this._metricsCache.getMarginSize(this._last);\n            if (margin === undefined) {\n                this._stable = false;\n                margin = this._metricsCache.averageMarginSize;\n            }\n            const pos = this._physicalMax;\n            items.set(this._last, { pos, size });\n            this._physicalMax += size + margin;\n            if (!this._stable && !this._estimate) {\n                break;\n            }\n        }\n        // This handles the cases where we were relying on estimated sizes.\n        const extentErr = this._calculateError();\n        if (extentErr) {\n            this._physicalMin -= extentErr;\n            this._physicalMax -= extentErr;\n            this._anchorPos -= extentErr;\n            this._scrollPosition -= extentErr;\n            items.forEach((item) => (item.pos -= extentErr));\n            this._scrollError += extentErr;\n        }\n        if (this._stable) {\n            this._newPhysicalItems = this._physicalItems;\n            this._newPhysicalItems.clear();\n            this._physicalItems = items;\n        }\n    }\n    _calculateError() {\n        if (this._first === 0) {\n            return this._physicalMin;\n        }\n        else if (this._physicalMin <= 0) {\n            return this._physicalMin - this._first * this._delta;\n        }\n        else if (this._last === this.items.length - 1) {\n            return this._physicalMax - this._scrollSize;\n        }\n        else if (this._physicalMax >= this._scrollSize) {\n            return (this._physicalMax -\n                this._scrollSize +\n                (this.items.length - 1 - this._last) * this._delta);\n        }\n        return 0;\n    }\n    _reflow() {\n        const { _first, _last } = this;\n        super._reflow();\n        if ((this._first === -1 && this._last == -1) ||\n            (this._first === _first && this._last === _last)) {\n            this._resetReflowState();\n        }\n    }\n    _resetReflowState() {\n        this._anchorIdx = null;\n        this._anchorPos = null;\n        this._stable = true;\n    }\n    _updateScrollSize() {\n        const { averageMarginSize } = this._metricsCache;\n        this._scrollSize = Math.max(1, this.items.length * (averageMarginSize + this._getAverageSize()) +\n            averageMarginSize);\n    }\n    /**\n     * Returns the average size (precise or estimated) of an item in the scrolling direction,\n     * including any surrounding space.\n     */\n    get _delta() {\n        const { averageMarginSize } = this._metricsCache;\n        return this._getAverageSize() + averageMarginSize;\n    }\n    /**\n     * Returns the top and left positioning of the item at idx.\n     */\n    _getItemPosition(idx) {\n        var _a;\n        return {\n            [this._positionDim]: this._getPosition(idx),\n            [this._secondaryPositionDim]: 0,\n            [offset(this.direction)]: -((_a = this._metricsCache.getLeadingMarginValue(idx, this.direction)) !== null && _a !== void 0 ? _a : this._metricsCache.averageMarginSize),\n        };\n    }\n    /**\n     * Returns the height and width of the item at idx.\n     */\n    _getItemSize(idx) {\n        return {\n            [this._sizeDim]: this._getSize(idx) || this._getAverageSize(),\n            [this._secondarySizeDim]: this._itemSize[this._secondarySizeDim],\n        };\n    }\n    _viewDim2Changed() {\n        this._metricsCache.clear();\n        this._scheduleReflow();\n    }\n}\n//# sourceMappingURL=flow.js.map"],"names":["SizeCache","constructor","config","this","_map","Map","_roundAverageSize","totalSize","roundAverageSize","set","index","value","prev","get","averageSize","size","average","Math","round","getSize","clear","dim1","direction","BaseLayout","hostSink","_latestCoords","left","top","_direction","_viewportSize","width","height","totalScrollSize","offsetWithinScroller","_pendingReflow","_pendingLayoutUpdate","_pin","_firstVisible","_lastVisible","_physicalMin","_physicalMax","_first","_last","_sizeDim","_secondarySizeDim","_positionDim","_secondaryPositionDim","_scrollPosition","_scrollError","_items","_scrollSize","_overhang","_hostSink","Promise","resolve","then","_getDefaultConfig","Object","assign","items","_setItems","_scheduleReflow","dir","_triggerReflow","viewportSize","dims","_viewDim1","_viewDim2","_scheduleLayoutUpdate","_checkThresholds","viewportScroll","coords","oldPos","abs","reflowIfNeeded","force","_reflow","pin","options","block","max","min","length","_clampScrollPosition","val","unpin","_sendUnpinnedMessage","_updateLayout","_updateScrollSize","_setPositionFromPin","_getActiveItems","_updateVisibleIndices","_sendStateChangedMessage","lastScrollPosition","_calculateScrollIntoViewPosition","itemStartPosition","_getItemPosition","scrollPosition","itemSize","_getItemSize","itemEndPosition","currentScrollPosition","getScrollIntoViewCoordinates","type","_sendVisibilityChangedMessage","firstVisible","lastVisible","childPositions","idx","message","scrollSize","range","first","last","scrollError","_num","emit","flow","FlowLayout","leadingMargin","trailingMargin","collapseMargins","a","b","m","sort","MetricsCache","_childSizeCache","_marginSizeCache","_metricsCache","update","metrics","_a","_b","marginsToUpdate","Set","keys","forEach","key","k","Number","add","averageChildSize","totalChildSize","averageMarginSize","totalMarginSize","getLeadingMarginValue","getChildSize","getMarginSize","super","arguments","_itemSize","_physicalItems","_newPhysicalItems","_anchorIdx","_anchorPos","_stable","_measureChildren","_estimate","measureChildren","updateItemSizes","sizes","_getPhysicalItem","_getSize","_getAverageSize","_estimatePosition","c","delta","pos","_getPosition","item","_calculateAnchor","lower","upper","floor","_delta","_getAnchor","firstItem","lastItem","firstMin","candidateIdx","cMax","_clearItems","_getItems","anchorSize","undefined","anchorLeadingMargin","anchorTrailingMargin","anchorErr","margin","extentErr","_calculateError","_resetReflowState","_viewDim2Changed"],"sourceRoot":""}